/*
NetBox REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 4.1.4 (4.1)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
       "time"
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// PluginsAPIService PluginsAPI service
type PluginsAPIService service

type ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	netBoxAttachmentRequest *[]NetBoxAttachmentRequest
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkDestroyRequest) NetBoxAttachmentRequest(netBoxAttachmentRequest []NetBoxAttachmentRequest) ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkDestroyRequest {
	r.netBoxAttachmentRequest = &netBoxAttachmentRequest
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsNetboxAttachmentsNetboxAttachmentsBulkDestroyExecute(r)
}

/*
PluginsNetboxAttachmentsNetboxAttachmentsBulkDestroy Method for PluginsNetboxAttachmentsNetboxAttachmentsBulkDestroy

Delete a list of NetBox Attachment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkDestroyRequest
*/
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsBulkDestroy(ctx context.Context) ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkDestroyRequest {
	return ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsBulkDestroyExecute(r ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxAttachmentsNetboxAttachmentsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox-attachments/netbox-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.netBoxAttachmentRequest == nil {
		return nil, reportError("netBoxAttachmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.netBoxAttachmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	netBoxAttachmentRequest *[]NetBoxAttachmentRequest
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdateRequest) NetBoxAttachmentRequest(netBoxAttachmentRequest []NetBoxAttachmentRequest) ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdateRequest {
	r.netBoxAttachmentRequest = &netBoxAttachmentRequest
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdateRequest) Execute() ([]NetBoxAttachment, *http.Response, error) {
	return r.ApiService.PluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdateExecute(r)
}

/*
PluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdate Method for PluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdate

Patch a list of NetBox Attachment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdate(ctx context.Context) ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdateRequest {
	return ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NetBoxAttachment
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdateExecute(r ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdateRequest) ([]NetBoxAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NetBoxAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxAttachmentsNetboxAttachmentsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox-attachments/netbox-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.netBoxAttachmentRequest == nil {
		return localVarReturnValue, nil, reportError("netBoxAttachmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.netBoxAttachmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	netBoxAttachmentRequest *[]NetBoxAttachmentRequest
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkUpdateRequest) NetBoxAttachmentRequest(netBoxAttachmentRequest []NetBoxAttachmentRequest) ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkUpdateRequest {
	r.netBoxAttachmentRequest = &netBoxAttachmentRequest
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkUpdateRequest) Execute() ([]NetBoxAttachment, *http.Response, error) {
	return r.ApiService.PluginsNetboxAttachmentsNetboxAttachmentsBulkUpdateExecute(r)
}

/*
PluginsNetboxAttachmentsNetboxAttachmentsBulkUpdate Method for PluginsNetboxAttachmentsNetboxAttachmentsBulkUpdate

Put a list of NetBox Attachment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkUpdateRequest
*/
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsBulkUpdate(ctx context.Context) ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkUpdateRequest {
	return ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NetBoxAttachment
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsBulkUpdateExecute(r ApiPluginsNetboxAttachmentsNetboxAttachmentsBulkUpdateRequest) ([]NetBoxAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NetBoxAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxAttachmentsNetboxAttachmentsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox-attachments/netbox-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.netBoxAttachmentRequest == nil {
		return localVarReturnValue, nil, reportError("netBoxAttachmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.netBoxAttachmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxAttachmentsNetboxAttachmentsCreateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	netBoxAttachmentRequest *NetBoxAttachmentRequest
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsCreateRequest) NetBoxAttachmentRequest(netBoxAttachmentRequest NetBoxAttachmentRequest) ApiPluginsNetboxAttachmentsNetboxAttachmentsCreateRequest {
	r.netBoxAttachmentRequest = &netBoxAttachmentRequest
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsCreateRequest) Execute() (*NetBoxAttachment, *http.Response, error) {
	return r.ApiService.PluginsNetboxAttachmentsNetboxAttachmentsCreateExecute(r)
}

/*
PluginsNetboxAttachmentsNetboxAttachmentsCreate Method for PluginsNetboxAttachmentsNetboxAttachmentsCreate

Post a list of NetBox Attachment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsNetboxAttachmentsNetboxAttachmentsCreateRequest
*/
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsCreate(ctx context.Context) ApiPluginsNetboxAttachmentsNetboxAttachmentsCreateRequest {
	return ApiPluginsNetboxAttachmentsNetboxAttachmentsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NetBoxAttachment
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsCreateExecute(r ApiPluginsNetboxAttachmentsNetboxAttachmentsCreateRequest) (*NetBoxAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetBoxAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxAttachmentsNetboxAttachmentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox-attachments/netbox-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.netBoxAttachmentRequest == nil {
		return localVarReturnValue, nil, reportError("netBoxAttachmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.netBoxAttachmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxAttachmentsNetboxAttachmentsDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsNetboxAttachmentsNetboxAttachmentsDestroyExecute(r)
}

/*
PluginsNetboxAttachmentsNetboxAttachmentsDestroy Method for PluginsNetboxAttachmentsNetboxAttachmentsDestroy

Delete a NetBox Attachment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this NetBox Attachment.
 @return ApiPluginsNetboxAttachmentsNetboxAttachmentsDestroyRequest
*/
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsDestroy(ctx context.Context, id int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsDestroyRequest {
	return ApiPluginsNetboxAttachmentsNetboxAttachmentsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsDestroyExecute(r ApiPluginsNetboxAttachmentsNetboxAttachmentsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxAttachmentsNetboxAttachmentsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox-attachments/netbox-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	created *time.Time
	createdByRequest *string
	description *string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *string
	objectId *[]int32
	objectIdEmpty *bool
	objectIdGt *[]int32
	objectIdGte *[]int32
	objectIdLt *[]int32
	objectIdLte *[]int32
	objectIdN *[]int32
	objectType *string
	objectTypeN *string
	objectTypeId *int32
	objectTypeIdN *int32
	offset *int32
	ordering *string
	q *string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) Created(created time.Time) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.created = &created
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) CreatedByRequest(createdByRequest string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) Description(description string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.description = &description
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) Id(id []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.id = &id
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) IdEmpty(idEmpty bool) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) IdGt(idGt []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) IdGte(idGte []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) IdLt(idLt []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) IdLte(idLte []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) IdN(idN []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.idN = &idN
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) LastUpdated(lastUpdated []time.Time) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) Limit(limit int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.limit = &limit
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ModifiedByRequest(modifiedByRequest string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) Name(name string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.name = &name
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectId(objectId []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectId = &objectId
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectIdEmpty(objectIdEmpty bool) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectIdEmpty = &objectIdEmpty
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectIdGt(objectIdGt []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectIdGt = &objectIdGt
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectIdGte(objectIdGte []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectIdGte = &objectIdGte
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectIdLt(objectIdLt []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectIdLt = &objectIdLt
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectIdLte(objectIdLte []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectIdLte = &objectIdLte
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectIdN(objectIdN []int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectIdN = &objectIdN
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectType(objectType string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectType = &objectType
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectTypeN(objectTypeN string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectTypeN = &objectTypeN
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectTypeId(objectTypeId int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectTypeId = &objectTypeId
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) ObjectTypeIdN(objectTypeIdN int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.objectTypeIdN = &objectTypeIdN
	return r
}

// The initial index from which to return the results.
func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) Offset(offset int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) Ordering(ordering string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) Q(q string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.q = &q
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) Tag(tag []string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.tag = &tag
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) TagN(tagN []string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) UpdatedByRequest(updatedByRequest string) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) Execute() (*PaginatedNetBoxAttachmentList, *http.Response, error) {
	return r.ApiService.PluginsNetboxAttachmentsNetboxAttachmentsListExecute(r)
}

/*
PluginsNetboxAttachmentsNetboxAttachmentsList Method for PluginsNetboxAttachmentsNetboxAttachmentsList

Get a list of NetBox Attachment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest
*/
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsList(ctx context.Context) ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest {
	return ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedNetBoxAttachmentList
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsListExecute(r ApiPluginsNetboxAttachmentsNetboxAttachmentsListRequest) (*PaginatedNetBoxAttachmentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNetBoxAttachmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxAttachmentsNetboxAttachmentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox-attachments/netbox-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created", r.created, "form", "")
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.objectId != nil {
		t := *r.objectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_id", t, "form", "multi")
		}
	}
	if r.objectIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__empty", r.objectIdEmpty, "form", "")
	}
	if r.objectIdGt != nil {
		t := *r.objectIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__gt", t, "form", "multi")
		}
	}
	if r.objectIdGte != nil {
		t := *r.objectIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__gte", t, "form", "multi")
		}
	}
	if r.objectIdLt != nil {
		t := *r.objectIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__lt", t, "form", "multi")
		}
	}
	if r.objectIdLte != nil {
		t := *r.objectIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__lte", t, "form", "multi")
		}
	}
	if r.objectIdN != nil {
		t := *r.objectIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_id__n", t, "form", "multi")
		}
	}
	if r.objectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type", r.objectType, "form", "")
	}
	if r.objectTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__n", r.objectTypeN, "form", "")
	}
	if r.objectTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type_id", r.objectTypeId, "form", "")
	}
	if r.objectTypeIdN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type_id__n", r.objectTypeIdN, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxAttachmentsNetboxAttachmentsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	patchedNetBoxAttachmentRequest *PatchedNetBoxAttachmentRequest
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsPartialUpdateRequest) PatchedNetBoxAttachmentRequest(patchedNetBoxAttachmentRequest PatchedNetBoxAttachmentRequest) ApiPluginsNetboxAttachmentsNetboxAttachmentsPartialUpdateRequest {
	r.patchedNetBoxAttachmentRequest = &patchedNetBoxAttachmentRequest
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsPartialUpdateRequest) Execute() (*NetBoxAttachment, *http.Response, error) {
	return r.ApiService.PluginsNetboxAttachmentsNetboxAttachmentsPartialUpdateExecute(r)
}

/*
PluginsNetboxAttachmentsNetboxAttachmentsPartialUpdate Method for PluginsNetboxAttachmentsNetboxAttachmentsPartialUpdate

Patch a NetBox Attachment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this NetBox Attachment.
 @return ApiPluginsNetboxAttachmentsNetboxAttachmentsPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsPartialUpdate(ctx context.Context, id int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsPartialUpdateRequest {
	return ApiPluginsNetboxAttachmentsNetboxAttachmentsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NetBoxAttachment
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsPartialUpdateExecute(r ApiPluginsNetboxAttachmentsNetboxAttachmentsPartialUpdateRequest) (*NetBoxAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetBoxAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxAttachmentsNetboxAttachmentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox-attachments/netbox-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedNetBoxAttachmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxAttachmentsNetboxAttachmentsRetrieveRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsRetrieveRequest) Execute() (*NetBoxAttachment, *http.Response, error) {
	return r.ApiService.PluginsNetboxAttachmentsNetboxAttachmentsRetrieveExecute(r)
}

/*
PluginsNetboxAttachmentsNetboxAttachmentsRetrieve Method for PluginsNetboxAttachmentsNetboxAttachmentsRetrieve

Get a NetBox Attachment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this NetBox Attachment.
 @return ApiPluginsNetboxAttachmentsNetboxAttachmentsRetrieveRequest
*/
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsRetrieve(ctx context.Context, id int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsRetrieveRequest {
	return ApiPluginsNetboxAttachmentsNetboxAttachmentsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NetBoxAttachment
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsRetrieveExecute(r ApiPluginsNetboxAttachmentsNetboxAttachmentsRetrieveRequest) (*NetBoxAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetBoxAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxAttachmentsNetboxAttachmentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox-attachments/netbox-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxAttachmentsNetboxAttachmentsUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	netBoxAttachmentRequest *NetBoxAttachmentRequest
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsUpdateRequest) NetBoxAttachmentRequest(netBoxAttachmentRequest NetBoxAttachmentRequest) ApiPluginsNetboxAttachmentsNetboxAttachmentsUpdateRequest {
	r.netBoxAttachmentRequest = &netBoxAttachmentRequest
	return r
}

func (r ApiPluginsNetboxAttachmentsNetboxAttachmentsUpdateRequest) Execute() (*NetBoxAttachment, *http.Response, error) {
	return r.ApiService.PluginsNetboxAttachmentsNetboxAttachmentsUpdateExecute(r)
}

/*
PluginsNetboxAttachmentsNetboxAttachmentsUpdate Method for PluginsNetboxAttachmentsNetboxAttachmentsUpdate

Put a NetBox Attachment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this NetBox Attachment.
 @return ApiPluginsNetboxAttachmentsNetboxAttachmentsUpdateRequest
*/
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsUpdate(ctx context.Context, id int32) ApiPluginsNetboxAttachmentsNetboxAttachmentsUpdateRequest {
	return ApiPluginsNetboxAttachmentsNetboxAttachmentsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NetBoxAttachment
func (a *PluginsAPIService) PluginsNetboxAttachmentsNetboxAttachmentsUpdateExecute(r ApiPluginsNetboxAttachmentsNetboxAttachmentsUpdateRequest) (*NetBoxAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetBoxAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxAttachmentsNetboxAttachmentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox-attachments/netbox-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.netBoxAttachmentRequest == nil {
		return localVarReturnValue, nil, reportError("netBoxAttachmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.netBoxAttachmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxTopologyViewsImagesListRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	limit *int32
	offset *int32
	ordering *string
}

// Number of results to return per page.
func (r ApiPluginsNetboxTopologyViewsImagesListRequest) Limit(limit int32) ApiPluginsNetboxTopologyViewsImagesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiPluginsNetboxTopologyViewsImagesListRequest) Offset(offset int32) ApiPluginsNetboxTopologyViewsImagesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiPluginsNetboxTopologyViewsImagesListRequest) Ordering(ordering string) ApiPluginsNetboxTopologyViewsImagesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiPluginsNetboxTopologyViewsImagesListRequest) Execute() (*PaginatedRoleImageList, *http.Response, error) {
	return r.ApiService.PluginsNetboxTopologyViewsImagesListExecute(r)
}

/*
PluginsNetboxTopologyViewsImagesList Method for PluginsNetboxTopologyViewsImagesList

Get a list of device role objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsNetboxTopologyViewsImagesListRequest
*/
func (a *PluginsAPIService) PluginsNetboxTopologyViewsImagesList(ctx context.Context) ApiPluginsNetboxTopologyViewsImagesListRequest {
	return ApiPluginsNetboxTopologyViewsImagesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRoleImageList
func (a *PluginsAPIService) PluginsNetboxTopologyViewsImagesListExecute(r ApiPluginsNetboxTopologyViewsImagesListRequest) (*PaginatedRoleImageList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRoleImageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxTopologyViewsImagesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox_topology_views/images/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxTopologyViewsImagesRetrieveRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsNetboxTopologyViewsImagesRetrieveRequest) Execute() (*RoleImage, *http.Response, error) {
	return r.ApiService.PluginsNetboxTopologyViewsImagesRetrieveExecute(r)
}

/*
PluginsNetboxTopologyViewsImagesRetrieve Method for PluginsNetboxTopologyViewsImagesRetrieve

Get a device role object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device role.
 @return ApiPluginsNetboxTopologyViewsImagesRetrieveRequest
*/
func (a *PluginsAPIService) PluginsNetboxTopologyViewsImagesRetrieve(ctx context.Context, id int32) ApiPluginsNetboxTopologyViewsImagesRetrieveRequest {
	return ApiPluginsNetboxTopologyViewsImagesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RoleImage
func (a *PluginsAPIService) PluginsNetboxTopologyViewsImagesRetrieveExecute(r ApiPluginsNetboxTopologyViewsImagesRetrieveRequest) (*RoleImage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxTopologyViewsImagesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox_topology_views/images/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxTopologyViewsImagesSaveCreateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	roleImageRequest *RoleImageRequest
}

func (r ApiPluginsNetboxTopologyViewsImagesSaveCreateRequest) RoleImageRequest(roleImageRequest RoleImageRequest) ApiPluginsNetboxTopologyViewsImagesSaveCreateRequest {
	r.roleImageRequest = &roleImageRequest
	return r
}

func (r ApiPluginsNetboxTopologyViewsImagesSaveCreateRequest) Execute() (*RoleImage, *http.Response, error) {
	return r.ApiService.PluginsNetboxTopologyViewsImagesSaveCreateExecute(r)
}

/*
PluginsNetboxTopologyViewsImagesSaveCreate Method for PluginsNetboxTopologyViewsImagesSaveCreate

Post a list of device role objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsNetboxTopologyViewsImagesSaveCreateRequest
*/
func (a *PluginsAPIService) PluginsNetboxTopologyViewsImagesSaveCreate(ctx context.Context) ApiPluginsNetboxTopologyViewsImagesSaveCreateRequest {
	return ApiPluginsNetboxTopologyViewsImagesSaveCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoleImage
func (a *PluginsAPIService) PluginsNetboxTopologyViewsImagesSaveCreateExecute(r ApiPluginsNetboxTopologyViewsImagesSaveCreateRequest) (*RoleImage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxTopologyViewsImagesSaveCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox_topology_views/images/save/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleImageRequest == nil {
		return localVarReturnValue, nil, reportError("roleImageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleImageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxTopologyViewsSaveCoordsListRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	limit *int32
	offset *int32
	ordering *string
}

// Number of results to return per page.
func (r ApiPluginsNetboxTopologyViewsSaveCoordsListRequest) Limit(limit int32) ApiPluginsNetboxTopologyViewsSaveCoordsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiPluginsNetboxTopologyViewsSaveCoordsListRequest) Offset(offset int32) ApiPluginsNetboxTopologyViewsSaveCoordsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiPluginsNetboxTopologyViewsSaveCoordsListRequest) Ordering(ordering string) ApiPluginsNetboxTopologyViewsSaveCoordsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiPluginsNetboxTopologyViewsSaveCoordsListRequest) Execute() (*PaginatedTopologyDummyList, *http.Response, error) {
	return r.ApiService.PluginsNetboxTopologyViewsSaveCoordsListExecute(r)
}

/*
PluginsNetboxTopologyViewsSaveCoordsList Method for PluginsNetboxTopologyViewsSaveCoordsList

Get a list of device objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsNetboxTopologyViewsSaveCoordsListRequest
*/
func (a *PluginsAPIService) PluginsNetboxTopologyViewsSaveCoordsList(ctx context.Context) ApiPluginsNetboxTopologyViewsSaveCoordsListRequest {
	return ApiPluginsNetboxTopologyViewsSaveCoordsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedTopologyDummyList
func (a *PluginsAPIService) PluginsNetboxTopologyViewsSaveCoordsListExecute(r ApiPluginsNetboxTopologyViewsSaveCoordsListRequest) (*PaginatedTopologyDummyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTopologyDummyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxTopologyViewsSaveCoordsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox_topology_views/save-coords/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxTopologyViewsSaveCoordsRetrieveRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsNetboxTopologyViewsSaveCoordsRetrieveRequest) Execute() (*TopologyDummy, *http.Response, error) {
	return r.ApiService.PluginsNetboxTopologyViewsSaveCoordsRetrieveExecute(r)
}

/*
PluginsNetboxTopologyViewsSaveCoordsRetrieve Method for PluginsNetboxTopologyViewsSaveCoordsRetrieve

Get a device object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiPluginsNetboxTopologyViewsSaveCoordsRetrieveRequest
*/
func (a *PluginsAPIService) PluginsNetboxTopologyViewsSaveCoordsRetrieve(ctx context.Context, id int32) ApiPluginsNetboxTopologyViewsSaveCoordsRetrieveRequest {
	return ApiPluginsNetboxTopologyViewsSaveCoordsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TopologyDummy
func (a *PluginsAPIService) PluginsNetboxTopologyViewsSaveCoordsRetrieveExecute(r ApiPluginsNetboxTopologyViewsSaveCoordsRetrieveRequest) (*TopologyDummy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TopologyDummy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxTopologyViewsSaveCoordsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox_topology_views/save-coords/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	patchedTopologyDummyRequest *PatchedTopologyDummyRequest
}

func (r ApiPluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdateRequest) PatchedTopologyDummyRequest(patchedTopologyDummyRequest PatchedTopologyDummyRequest) ApiPluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdateRequest {
	r.patchedTopologyDummyRequest = &patchedTopologyDummyRequest
	return r
}

func (r ApiPluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdateRequest) Execute() (*TopologyDummy, *http.Response, error) {
	return r.ApiService.PluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdateExecute(r)
}

/*
PluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdate Method for PluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdate

Patch a list of device objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdate(ctx context.Context) ApiPluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdateRequest {
	return ApiPluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TopologyDummy
func (a *PluginsAPIService) PluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdateExecute(r ApiPluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdateRequest) (*TopologyDummy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TopologyDummy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxTopologyViewsSaveCoordsSaveCoordsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox_topology_views/save-coords/save_coords/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTopologyDummyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsNetboxTopologyViewsXmlExportListRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	limit *int32
	offset *int32
	ordering *string
}

// Number of results to return per page.
func (r ApiPluginsNetboxTopologyViewsXmlExportListRequest) Limit(limit int32) ApiPluginsNetboxTopologyViewsXmlExportListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiPluginsNetboxTopologyViewsXmlExportListRequest) Offset(offset int32) ApiPluginsNetboxTopologyViewsXmlExportListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiPluginsNetboxTopologyViewsXmlExportListRequest) Ordering(ordering string) ApiPluginsNetboxTopologyViewsXmlExportListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiPluginsNetboxTopologyViewsXmlExportListRequest) Execute() (*PaginatedTopologyDummyList, *http.Response, error) {
	return r.ApiService.PluginsNetboxTopologyViewsXmlExportListExecute(r)
}

/*
PluginsNetboxTopologyViewsXmlExportList Method for PluginsNetboxTopologyViewsXmlExportList

Get a list of device objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsNetboxTopologyViewsXmlExportListRequest
*/
func (a *PluginsAPIService) PluginsNetboxTopologyViewsXmlExportList(ctx context.Context) ApiPluginsNetboxTopologyViewsXmlExportListRequest {
	return ApiPluginsNetboxTopologyViewsXmlExportListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedTopologyDummyList
func (a *PluginsAPIService) PluginsNetboxTopologyViewsXmlExportListExecute(r ApiPluginsNetboxTopologyViewsXmlExportListRequest) (*PaginatedTopologyDummyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTopologyDummyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsNetboxTopologyViewsXmlExportList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/netbox_topology_views/xml-export/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
